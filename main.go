package main

import (
	"context"
	"flag"
	"fmt"
	"log"
	"os"
	"path/filepath"
	"sort"
	"time"

	"github.com/gorilla/feeds"
	"golang.org/x/oauth2/google"
	"google.golang.org/api/gmail/v1"
	"google.golang.org/api/option"
)

const name = "gr"

type Message struct {
	Id      string
	Author  string
	Date    time.Time
	Subject string
	Summery string
}

func newService() (*gmail.Service, error) {
	ctx := context.Background()
	b, err := os.ReadFile(filepath.Join(getConfigDir(), "credentials.json"))
	if err != nil {
		return nil, err
	}

	// If modifying these scopes, delete your previously saved token.json.
	config, err := google.ConfigFromJSON(b, gmail.GmailReadonlyScope)
	if err != nil {
		return nil, err
	}
	client := getClient(config)

	srv, err := gmail.NewService(ctx, option.WithHTTPClient(client))
	if err != nil {
		return nil, err
	}

	return srv, err
}

func getMessage(m *gmail.Message) (*Message, error) {
	var (
		err     error
		subject string
		auther  string
		date    *time.Time
	)

	for _, h := range m.Payload.Headers {
		switch h.Name {
		case "Subject":
			subject = h.Value
		case "From":
			auther = h.Value
		case "Date":
			date, err = parseDate(h.Value)
			if err != nil {
				return nil, err
			}
		}
	}

	return &Message{
		Id:      m.Id,
		Author:  auther,
		Date:    *date,
		Subject: subject,
		Summery: m.Snippet,
	}, nil
}

func parseDate(v string) (*time.Time, error) {
	var date time.Time
	var err error
	layouts := []string{
		"Mon, 2 Jan 2006 15:04:05 -0700 (MST)",
		"Mon, 2 Jan 2006 15:04:05 -0700",
		"Mon, 2 Jan 2006 15:04:05 MST",
		"2 Jan 2006 15:04:05 -0700",
	}

	for _, l := range layouts {
		date, err = time.Parse(l, v)
		if err == nil {
			return &date, nil
		}
	}
	return nil, err
}

func main() {
	const gmailDomain = "https://mail.google.com/mail/u/0"

	flag.Usage = func() {
		fmt.Fprintf(os.Stderr, "Usage:\n  %s [Arguments]\nArguments:\n  available labels on your account\n", os.Args[0])
		flag.PrintDefaults()
	}

	flag.Parse()
	if flag.NArg() == 0 {
		flag.Usage()
		return
	}

	srv, err := newService()
	if err != nil {
		log.Fatalln(err)
		return
	}

	user := "me"
	labelRes, err := srv.Users.Labels.List(user).Do()
	if len(labelRes.Labels) == 0 {
		fmt.Println("No labels found.")
		return
	}
	if err != nil {
		log.Fatalf("Unable to retrieve labels: %v", err)
	}

	labels := ""
	labelIds := []string{}
	for _, l := range labelRes.Labels {
		for _, a := range flag.Args() {
			if l.Name == a {
				labelIds = append(labelIds, l.Id)
				labels += l.Name + " "
				break
			}
		}
	}
	labels = labels[:len(labels)-1]

	if len(labelIds) == 0 {
		fmt.Print("At least one valid label name is required.")
		fmt.Println("Available labels on your account are:")
		for _, l := range labelRes.Labels {
			fmt.Println("  " + l.Name)
		}
		return
	}

	listCall := srv.Users.Messages.List(user)
	for _, l := range labelIds {
		listCall = listCall.LabelIds(l)
	}
	messageRes, err := listCall.Do()
	if err != nil {
		log.Fatalf("Unable to retrieve labels: %v", err)
	}
	if len(messageRes.Messages) == 0 {
		fmt.Println("No labels found.")
		return
	}

	c := make(chan *gmail.Message, len(messageRes.Messages))
	for _, m := range messageRes.Messages {
		go func(m *gmail.Message, c chan *gmail.Message) {
			message, err := srv.Users.Messages.Get(user, m.Id).Format("full").Do()
			if err != nil {
				log.Fatalf("Unable to retrieve a message: %v", err)
				return
			}
			c <- message
		}(m, c)
	}

	messages := make([]*feeds.Item, 0)
	for i := 0; i < len(messageRes.Messages); i++ {
		m := <-c

		newMessage, err := getMessage(m)
		if err != nil {
			log.Fatalf("Failed to retrieve a message: %v", err)
		}

		messages = append(messages, &feeds.Item{
			Title:       newMessage.Subject,
			Description: newMessage.Summery,
			Author:      &feeds.Author{Name: newMessage.Author},
			Created:     newMessage.Date,
			Link:        &feeds.Link{Href: gmailDomain + "/#inbox/" + newMessage.Id},
		})
	}

	sort.Slice(messages, func(i, j int) bool {
		return messages[i].Created.After(messages[j].Created)
	})

	feed := feeds.Feed{
		Title:       "Gmail(" + labels + ")",
		Items:       messages,
		Created:     time.Now(),
		Link:        &feeds.Link{Href: "https://mail.google.com"},
		Description: "generated by " + name,
		Author:      &feeds.Author{Name: name},
	}

	rss, _ := feed.ToRss()

	fmt.Println(rss)
}
